#事件处理模式
* 是服务器高效处理事件的模式
* 用于处理I/O事件，信号和定时事件
  
* 同步I/O模型通常用于实现Reactor模式
* 异步I/O模型则用于实现Proactor模式
* 可以使用同步I/O方式模拟出 Proactor模式
  
##Reactor：主线程只负责监听文件描述符事件，通知工作线程（逻辑单元）处理事件
* 主线程不做任何其他实质性的工作
* 读写数据，接受新的连接，以及处理客户请求均在工作线程中完成
  
###同步I/O模型（epoll_wait)实现Reactor模式的工作流程
1. 主线程往epoll内核事件表中注册socket上的读就绪事件
2. 主线程调用epoll_wait等待socket上有数据可读
3. 当socket上有数据可读时，epoll_wait通知主线程；主线程则将socket可读事件放入请求队列
4. 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
5. 主线程调用epoll_wait等待socket可写
6. 当socket可写时，epoll_wait通知主线程；主线程将socket可写事件放入请求队列
7. 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果 
  
* 事件的分类处理（包括I/O操作）完全交由工作线程完成，主线程不需要区分读/写工作线程，仅负责发布工作
##Proactor：主线程和内核责所有I/O操作，工作线程仅负责逻辑上的事务处理
* 完全分离I/O处理单元，逻辑单元，网络存储单元，彼此依次通过请求队列交互，使服务器基本框架层次分明逻辑清晰
###异步I/O模型（aio_read&&aio_write)实现Proactor模式的工作流程
1. 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的man手册） 
2. 主线程继续处理其他逻辑
3. 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用
4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求；工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）
5. 主线程继续处理其他逻辑
6. 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕
7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket
  
* conn套接字上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告conn套接字上的读写事件
* 主线程中的epoll_wait调用仅能用来检测listen套接字上的连接请求事件，而不能用来检测conn套接字上的读写事件
  

##模拟Proactor模式：同步I/O方式模拟
* 主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”
* 从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理
###同步I/O模型(epoll_wait)模拟Proactor模式工作流程
1. 主线程往epoll内核事件表中注册socket上的读就绪事件
2. 主线程调用epoll_wait等待socket上有数据可读
3. 当socket上有数据可读时，epoll_wait通知主线程；主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列
4. 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件
5. 主线程调用epoll_wait等待socket可写
6. 当socket可写时，epoll_wait通知主线程；主线程往socket上写入服务器处理客户请求的结果